defmodule AshCommanded.Commanded.Transformers.GenerateDomainRouterModule do
  @moduledoc """
  Generates a Commanded Router module for each Ash.Domain that contains resources
  with the AshCommanded.Commanded DSL extension.

  The domain router will route commands to their appropriate command handlers and aggregates.
  For domains with a single resource, it creates direct dispatch rules.
  For domains with multiple resources, it creates dispatch rules for each resource.
  """

  @behaviour Spark.Dsl.Transformer

  alias AshCommanded.Commanded.Info
  alias Ash.Resource.Info, as: ResourceInfo

  @impl true
  def transform(domain) do
    resources = get_commanded_resources(domain)

    unless resources == [] do
      create_domain_router(domain, resources)
    end

    {:ok, domain}
  end

  @impl true
  def after?(_), do: false

  @impl true
  def before?(_), do: false

  @impl true
  def after_compile?, do: false

  defp get_commanded_resources(domain) do
    Ash.Domain.Info.resources(domain)
    |> Enum.filter(fn resource ->
      Code.ensure_loaded?(resource) &&
        function_exported?(resource, :__ash_commanded_commanded__, 0)
    end)
  end

  defp create_domain_router(domain, resources) do
    router_module = domain_router_module(domain)

    unless Code.ensure_loaded?(router_module) do
      dispatch_rules = generate_dispatch_rules(resources)

      {:module, ^router_module, _, _} =
        Module.create(
          router_module,
          quote do
            @moduledoc """
            Commanded router for #{inspect(unquote(domain))}
            
            This module was automatically generated by AshCommanded.
            """
            use Commanded.Commands.Router

            unquote_splicing(dispatch_rules)
          end,
          Macro.Env.location(__ENV__)
        )
    end
  end

  defp generate_dispatch_rules(resources) do
    Enum.flat_map(resources, fn resource ->
      commands = Info.commands(resource)
      aggregate_mod = aggregate_module(resource)
      identity_field = get_identity_field(resource, commands)

      unless commands == [] do
        [
          quote do
            identify unquote(aggregate_mod), by: unquote(identity_field)
          end,
          quote do
            dispatch unquote(command_modules(resource, commands)), to: unquote(aggregate_mod)
          end
        ]
      else
        []
      end
    end)
  end

  defp aggregate_module(resource) do
    parts = Module.split(resource)
    ns = Enum.drop(parts, -1)
    name = List.last(parts) <> "Aggregate"
    Module.concat(ns ++ [name])
  end

  defp command_modules(resource, commands) do
    Enum.map(commands, fn command ->
      custom_ns = Module.get_attribute(resource, :command_namespace)

      base_parts =
        case custom_ns do
          nil ->
            parts = Module.split(resource) |> Enum.drop(-1)
            parts ++ ["Commands"]

          _ ->
            Module.split(custom_ns)
        end

      name_atom = command[:command_name] || Macro.camelize(to_string(command.name))
      Module.concat(base_parts ++ [name_atom])
    end)
  end

  defp get_identity_field(resource, commands) do
    # Try to get identity field from commands first
    command_identity =
      Enum.find_value(commands, fn command ->
        command[:identity_field]
      end)

    if command_identity do
      command_identity
    else
      # Fallback to resource identities
      identities = ResourceInfo.identities(resource)

      case identities do
        [%{keys: [single_key]} | _] when is_atom(single_key) -> single_key
        _ -> :id # Default to :id if no clear identity is found
      end
    end
  end

  defp domain_router_module(domain) do
    domain_parts = Module.split(domain)
    Module.concat(domain_parts ++ ["Router"])
  end
end