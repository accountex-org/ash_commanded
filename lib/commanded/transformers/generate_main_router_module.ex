defmodule AshCommanded.Commanded.Transformers.GenerateMainRouterModule do
  @moduledoc """
  Generates a main Commanded Router module based on the available Ash.Domains.

  This transformer has two behaviors:
  1. If there's only one domain with commanded resources, it will generate a main router
     with direct command dispatching.
  2. If there are multiple domains with commanded resources, it will generate a main router
     that forwards commands to the appropriate domain router.
  """

  @behaviour Spark.Dsl.Transformer

  alias AshCommanded.Commanded.Info
  alias Ash.Resource.Info, as: ResourceInfo

  @impl true
  def transform(resource_or_domain) do
    # We only want this to run once, so we'll check if we're processing the application module
    if is_app_module?(resource_or_domain) do
      domains = find_domains_with_commanded_resources()
      
      case domains do
        [] ->
          # No domains with commanded resources, nothing to do
          {:ok, resource_or_domain}
        
        [single_domain] ->
          # Single domain case - create main router with direct dispatching
          create_main_router_for_single_domain(single_domain)
          {:ok, resource_or_domain}
        
        _multiple_domains ->
          # Multiple domains case - create main router that forwards to domain routers
          create_main_router_for_multiple_domains(domains)
          {:ok, resource_or_domain}
      end
    else
      # Not the application module, pass through
      {:ok, resource_or_domain}
    end
  end

  @impl true
  def after?(_), do: false

  @impl true
  def before?(_), do: false

  @impl true
  def after_compile?, do: true # Run after compile to ensure all domains are processed

  defp is_app_module?(module) do
    # This is a heuristic to determine if we're processing the application module
    # You might need to adjust this based on your application structure
    Module.split(module) |> length() <= 2
  end

  defp find_domains_with_commanded_resources do
    # Find all domains that have resources with the commanded DSL
    # This is a placeholder - in a real implementation, you'd need to discover domains
    # through application configuration or other means
    for {app, _, _} <- :application.loaded_applications(),
        {:ok, modules} = :application.get_key(app, :modules),
        module <- modules,
        Code.ensure_loaded?(module),
        function_exported?(module, :__ash_domain__, 0),
        has_commanded_resources?(module) do
      module
    end
  end

  defp has_commanded_resources?(domain) do
    Ash.Domain.Info.resources(domain)
    |> Enum.any?(fn resource ->
      Code.ensure_loaded?(resource) &&
        function_exported?(resource, :__ash_commanded_commanded__, 0)
    end)
  end

  defp create_main_router_for_single_domain(domain) do
    router_module = main_router_module()
    resources = get_commanded_resources(domain)
    
    unless Code.ensure_loaded?(router_module) do
      dispatch_rules = generate_dispatch_rules(resources)

      {:module, ^router_module, _, _} =
        Module.create(
          router_module,
          quote do
            @moduledoc """
            Main Commanded router for the application
            
            This module was automatically generated by AshCommanded.
            """
            use Commanded.Commands.Router

            unquote_splicing(dispatch_rules)
          end,
          Macro.Env.location(__ENV__)
        )
    end
  end

  defp create_main_router_for_multiple_domains(domains) do
    router_module = main_router_module()
    
    unless Code.ensure_loaded?(router_module) do
      forward_rules = 
        for domain <- domains do
          domain_router = domain_router_module(domain)
          
          quote do
            forward unquote(domain_router)
          end
        end

      {:module, ^router_module, _, _} =
        Module.create(
          router_module,
          quote do
            @moduledoc """
            Main Commanded router for the application
            
            This module was automatically generated by AshCommanded.
            It forwards commands to domain-specific routers.
            """
            use Commanded.Commands.Router

            unquote_splicing(forward_rules)
          end,
          Macro.Env.location(__ENV__)
        )
    end
  end

  defp get_commanded_resources(domain) do
    Ash.Domain.Info.resources(domain)
    |> Enum.filter(fn resource ->
      Code.ensure_loaded?(resource) &&
        function_exported?(resource, :__ash_commanded_commanded__, 0)
    end)
  end

  defp generate_dispatch_rules(resources) do
    Enum.flat_map(resources, fn resource ->
      commands = Info.commands(resource)
      aggregate_mod = aggregate_module(resource)
      identity_field = get_identity_field(resource, commands)

      unless commands == [] do
        [
          quote do
            identify unquote(aggregate_mod), by: unquote(identity_field)
          end,
          quote do
            dispatch unquote(command_modules(resource, commands)), to: unquote(aggregate_mod)
          end
        ]
      else
        []
      end
    end)
  end

  defp aggregate_module(resource) do
    parts = Module.split(resource)
    ns = Enum.drop(parts, -1)
    name = List.last(parts) <> "Aggregate"
    Module.concat(ns ++ [name])
  end

  defp command_modules(resource, commands) do
    Enum.map(commands, fn command ->
      custom_ns = Module.get_attribute(resource, :command_namespace)

      base_parts =
        case custom_ns do
          nil ->
            parts = Module.split(resource) |> Enum.drop(-1)
            parts ++ ["Commands"]

          _ ->
            Module.split(custom_ns)
        end

      name_atom = command[:command_name] || Macro.camelize(to_string(command.name))
      Module.concat(base_parts ++ [name_atom])
    end)
  end

  defp get_identity_field(resource, commands) do
    # Try to get identity field from commands first
    command_identity =
      Enum.find_value(commands, fn command ->
        command[:identity_field]
      end)

    if command_identity do
      command_identity
    else
      # Fallback to resource identities
      identities = ResourceInfo.identities(resource)

      case identities do
        [%{keys: [single_key]} | _] when is_atom(single_key) -> single_key
        _ -> :id # Default to :id if no clear identity is found
      end
    end
  end

  defp main_router_module do
    # This should be configurable in a real implementation
    Module.concat(["AshCommanded", "Router"])
  end

  defp domain_router_module(domain) do
    domain_parts = Module.split(domain)
    Module.concat(domain_parts ++ ["Router"])
  end
end